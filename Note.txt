Venerdì 11/05/2018 - Provati modulini NRF24L01 con due sketch Arduino presi da internet.
Sul lato ricevitore, problemi con una funzione di ricezione che nella nuova libreria RF24 è stata cambiata.

Lunedì 27/08/2018
- Provato modulino SIM800L con alimentazione a 4.2V fornita da scheda XL4015. Ha funzionato bene per tutto il tempo, ovvero circa 3h di prove. Abbiamo quindi risolto il problema del reset continuo e di malfunzionamenti che si erano registrati usando la scheda originale con due diodi per passare da 5V a 4.2V.
- Provati i comandi:
	AT			per iniziare la comunicazione con il modulino grazie all'auto baud rate
	AT+CGMM 	Nome del modulo
	AT+CGMR		Codice del modulo
	AT+CPIN?	sapere se è richesto il PIN
	AT+CNUM		numero di telefono della SIM
	AT+CSQ		signal quality (risposta: 10 senza antenna, 26 con antenna)
	AT+CMGF=1	text mode, necessaria per leggere/inviare SMS
	AT+CMGS="+39........" INVIO >messaggio CTRL-Z 	per inviare SMS
	AT+CMGL="ALL"	legge tutti gli SMS
tutti hanno dato esito positivo, utilizzando un convertitore USB-seriale e il software PUTTY con comunicazione COM4 115200.

- Prova con ARDUINO e sketch seguente:
		#include <SoftwareSerial.h>

		String Arsp, Grsp;
		SoftwareSerial gsm(10, 11); // RX, TX (on Arduino side)

		void setup() {
		  // put your setup code here, to run once:

		  Serial.begin(9600);
		  Serial.println("Testing GSM SIM800L");
		  gsm.begin(4800);

		}

		void loop() {
		  // put your main code here, to run repeatedly:

		  if(gsm.available())
		  {
			Grsp = gsm.readString();
			Serial.println(Grsp);
		  }

		  if(Serial.available())
		  {
			Arsp = Serial.readString();
			gsm.println(Arsp);
		  }

		}

si è rivelata fallimentare in quanto molto lenta. Inoltre la lettura di tutti i messaggi non si conclude del tutto (forse a causa della software serial che ha un buffer troppo limitato). La VDD del SIM800L (lato seriale) era attaccata ai 3.3V di ARDUINO. Anche con 5V funziona male.

Abbiamo provato a 4800baud con putty e funziona benissimo.
	AT+CMGL="REC UNREAD"	legge tutti gli SMS non ancora letti

Abbiamo provato con la libreria NeoSwSerial al posto di SoftwareSerial ma non abbiamo ottenuto il miglioramento atteso. Ci siamo resi conto che quando si chiede la lettura di tutti i messaggi si superano gli 1.7kB rimanenti di memoria RAM di ARDUINO.
Link utile per comparazione software serial: https://arduino.stackexchange.com/questions/26240/which-pins-of-an-arduino-uno-can-be-used-as-tx-and-rx-pins-for-connecting-to-gsm#26277

Altri comandi provati: 
	AT+CLTS=1;&W abilita il servizio di orologio dalla rete e con l'opzione &W ne fa un settaggio permanente del modem (anche dopo reset HW resta)
	AT+CFUN=1,1		resetta il modulo via software
	AT+CLTS?		controlla se il clock via rete è attivo
	AT+CCLK?		restituisce ora corrente
Link di riferimento: https://elementztechblog.wordpress.com/2016/12/28/getting-time-and-date-from-gsm-modem/
	
Ora,quindi, è sufficiente AT+CCLK?	per ottenere l'ora corrente dalla rete.

2018.10.24 
Siamo riusciti a far funzionare il firmware: avviene una comunicazione bidirezionale tra PC-STM32-SIM800L basata su UART in interrupt mode e buffer circolare per la ricezione; aggiunte callback alla fine della trasmissione.
Pare funzionare ma resta da gestire l'eventualità di errori nella comunicazione, che con l'attuale error handler non vengono resettati opportunamente.
Ci siamo accorti che se l'antenna del SIM800L è vicina ai collegamenti con STM32, si ha sempre FE durante la ricezione di chiamate o SMS, che per il suddetto motivo manda in palla il sistema.

2018.11.06
Stiamo provando ad utilizzare un modulino NRF24L01 con STM32. Abbiamo problemi con la sequenza di power up, dove viene scritto un registro ma poi, alla rilettura, non risulta settato correttamente.
Abbiamo capito che ogni NRF24L01 consente di cambiare canale (quindi frequenza, attorno ai 2.4GHz, grazie ad un registro RF_CH) e sullo stesso canale è possibile assegnare vari indirizzi. Non abbiamo ben capito cosa siano le "pipe".
Stiamo provando a usare: https://github.com/r2aiv/NRF24L01-1

2018.11.08
Stiamo leggendo il datasheet e siamo arrivati a pagina 29/75.


Datasheet NRF24L01
	- Enhanced ShockBurst (ESB) - motore di protocollo in banda base integrato nel chip
		- comunicazione a pacchetti
		- operazioni manuali o avanzate autonome
		- gestisce tutte le operazioni a livello link
		- lunghezza payload dinamica da 1 a 32 byte
		- 6 data pipe (MultiCeiver) per connessioni a stella 1:6
	- Opera in banda ISM (Industrial Scientific Medical) da 2.4GHz a 2,525 GHZ (126 canali).
	- Mappa registri via SPI sempre accessibile
	- FIFO interne assicurano buon flusso dati tra radio e MCU
	- Front-end radio:
		- Modulazione GFSK (Gaussian Frequency Shift Keying) - è una modulazione FSK nella quale gli impulsi corrispondenti al dato digitale vengono "smussati" con un filtro graussiano prima di essere inviati al modulatore vero e proprio; in questo modo l'occupazione di banda viene ridotta (minori bande laterali attorno alla portante) ma aumenta l'interferenza inter-simbolica.
		- Configurabili: frequenza - 126 canali, potenza in uscita (0 -6 -12 -18 dBm) e data-rate in aria (250kBit/s, 1MBit/s, 2MBit/s)
	- Due modalità di risparmio di potenza; adatto per ultra-low power designs
	- Il "+" è compatibile con....ù
	- Gestione dell'alimentazione:
		- varie modalità: power-down, standby-I
		- 1.5ms power-down to power up
	- Interfaccia HOST
		- SPI 4 pin, max 10Mbit/s, 3FIFO TX/RX da 32byte (tot 6 FIFO)
		- Pin 5V tolerant (ma alimentazione da 1.9V a 3.6V)
	- PIN:
		- SPI usa MISO MOSI SCK CSN
		- CE attiva RX o TX
		- IRQ uscita interrupt attivo basso
---> da capire "power on reset" (5.7)

RADIO CONTROL
	- macchina a stati interna; prende input dai valori di registro definiti dall'utente e dai segnali interni
	- modi operativi:
		- power down ---> modulino disabilitato; valori dei registri mantenuti, SPI tenuta attiva e registri accessibili; ci si va con PWR_UP = 0 nel registro CONFIG;
		- standby; 
			- standby-I ---> ci si va con PWR_UP = 1 (e mantenendo il pin CE = 0); lo scopo è avere dei tempi di startup brevi pur non consumando troppo; qui solo una parte dell'oscillatore a cristallo è attivo;
			- standby-II ---> consuma un po' più di corrente; ci si va quando un PTX (Primary TX) ha buffer di TX vuoto e CE = 1; se la TX FIFO viene riempita, si torna in TX (130us per far ripartire PLL);
		- RX ---> ci si va da standby-I mettendo CE = 1 e PRIM_RX = 1 (ovviamente PWR_UP = 1); modulino come ricevitore: demodula i segnali dal canale RF presentando constantemente i dati in arrivo al "protocol engine". Esso ricerca costanemente per un pacchetto valido:
			- CRC valido
			- indirizzo corretto
			pacchetto valido ------> il payload è messo in una RX FIFO (se piene pacchetto è perduto).
nostra ipotesi: il "protocol engine" può commutare su modalità TX tramite le modalità automatiche del ESB ad esempio per ritrasmettere pacchetto a seguito di ricezione NACK
			- in RX si ha segnale RPD (Received Power Detector), che se alto, indica che c'è del segnale RF nel canale selezionato.
		
		- TX ---> ci si va da standby-I mettendo PRIM_RX = 0 (ovviamente PWR_UP = 1), un payload nella TX FIFO e un impulso su CE di almeno 10us; si usa per trasmettere e vi resta finché il pacchetto corrente non è stato trasmesso; dopodiché se CE = 0, passa in standby-I.
		Il modulino non deve restare in TX per più di 4ms (probabilmente per ragioni legate al PLL che opera in open loop); l'ESB rispetta questo vincolo.
		
		La tabella 15 (pag. 23) mostra un riassunto di come configurare queste modalità.
		
		Il modulino non ha memoria non volatile e se viene rimossa la VDD il contenuto dei registri va perduto.
	All'accensione, quando la VDD supera 1.9V, il modulino si mette in stato "power on reset" che dura al massimo 100ms, per poi andare automaticamente in "power down".
	Per andare in Standby devo porre PWR_UP = 1 nel registro di configurazione, dopodiché attendere 1.5ms.
	A questo punto, per fare ricezione o trasmissione devo mettere CE = 1 e scelgo TX/RX con PRIM_RX ( =0 --> TX).
	
	- air data rate
		si imposta con RF_DR nel registro RF_SETUP; il ricevitore e il trasmettitore devono avere stessa ADR per poter comunicare insieme.
	- canale in frequenza
		ogni canale occupa meno di 1MHz (250kbps, 1Mbps) o meno di 2MHz (2Mbps);
		risoluzione di scelta del canale: 1MHz;
		
		F0 = 2400 + RF_CH [MHz]
		
	- power amplifier controlla
		usato per impostare potenza in tx (4 scelte possibili)
		
ENHANCED SHOCK-BURST
E' un datalink layer basato su pacchetti; assembla e temporizza i pacchetti e gestisce ACK e ritrasmissione.
	- 1 - 32 byte payload
	- auto ACK con payload e auto-retransmit
	- 6 data pipe per reti a stella 1:6
	
ESB fornisce comunicazione bidirezionale affidabile in modo semplice.
Una transazione di pacchetto con ESB prevede la presenza di un PRX e di un PTX; inizia con trasmissione da PTX e finisce quando il PTX riceve un ACK dal PRX (il quale può restiuire assieme all'ACK anche dati ---> comunicazione bidirezionale).
ESB quindi gestisce PTX e PRX facendoli automaticamente commutare da modo TX a modo RX e viceversa. Tutto però parte con una TX dal PTX.
Si possono configurare max numero ritrasmissioni e ritardo tra una e l'altra.
		
	- Struttura pacchetto:
		- preambolo 01010101 = 85d (se primo bit indirizzo è 0) oppure 10101010 = 170d (se primo bit indirizzo è 1); serve per stabilizzare ricevitore;
		- indirizzo per il ricevitore; si può configurare la sua lunghezza tra 3, 4, 5 byte con il registro AW; non usare sequenze con una sola transizione tipo 000FFFFFh oppure con tutte transizioni (tipo preambolo)
		- campo "packet control" (9 bit); contiene lunghezza del payload (usato solo se è abilitata la "dynamic payload length - Se è 0 vuol dire vuoto e si usa per mandare solo ACK), identificativo pacchetto (PID - utile per far capire al PRX se il pacchetto è una ritrasmissione (stesso PID) oppure un pacchetto nuovo) e un bit di flag NO_ACK (usato solo se autoACK è attivo).
		-----> nota su NO_ACK; se NO_ACK = 1, vuol dire che questo pacchetto non deve essere acknowledge (il ricevitore non deve dire "io l'ho ricevuto")
		- CRC da 1 o 2 byte.
	
	- Gestione automatica del pacchetto:
		- lunghezza del payload statica (di default) o dinamica
			- statica: il TX riempie adeguatamente la FIFO, mentre l'RX ha un registro (RX_PW_Px) per indicare la lunghezza; le due devono essere coerenti.
			- dinamica: l'RX può decodificare automaticamente perché l'info sulla lunghezza è contenuta nel pacchetto; la MCU può chiedere al modulino RX la lunghezza del pacchetto con il comando R_RX_PL_WID; per abilitarla EN_DPL = 1 nel registro FEATURE sia del tx che del rx; inoltre impostazione registro DYNPD (Vedi pag. 29).
		- assemblamento, validazione, disassemblamento automatici
		
		
	
		